use kalko::*;

pub fn evaluate(problems: [(&str, f32); 10]) {
    let mut count = 0;
    while count < problems.len() {
        assert_eq!(calculate(problems[count].0), problems[count].1);
        count += 1;
    }
}

#[test]
fn basic_operation() {
    const PROBLEMS: [(&str, f32); 10] = [
        ("1+1", 2.0),
        ("1-4", -3.0),
        ("4x19", 76.0),
        ("1/1", 1.0),
        ("10+2-6", 6.0),
        ("6/3x2", 4.0),
        ("2-2x4+3/2", -4.5),
        ("10/2+3-1x10", -2.0),
        ("10+9/3+1-18x4-10+111-99x2", -155.0),
        ("11x2/3+10/3x100-100+43/32-10+1x2/13-19+213", 426.16425),
    ];

    evaluate(PROBLEMS);
}

#[test]
fn negative_value() {
    const PROBLEMS: [(&str, f32); 10] = [
        ("1+-1", 0.0),
        ("1--4", 5.0),
        ("-4x19", -76.0),
        ("-1/-1", 1.0),
        ("10+2--6", 18.0),
        ("-6/-3x-2", -4.0),
        ("2-2x4+-3/2", -7.5),
        ("10/2+3-1x-10", 18.0),
        ("1--1-2----10--------20------19+-10/2-2x18", 8.0),
        (
            "-10/-2+-10--12x-19+-13/-21--12--13+-19x-31/31+1",
            -187.38095,
        ),
    ];

    evaluate(PROBLEMS);
}

#[test]
fn parentheses() {
    const PROBLEMS: [(&str, f32); 10] = [
        ("1+(-1+2)", 2.0),
        ("(2-1)-4", -3.0),
        ("4x(19+3)", 88.0),
        ("(((10+(2-3))))/((2+3))", 1.8),
        ("(-2-2)x(4+3)/2", -14.0),
        ("((((1+2))))-2", 1.0),
        ("-(-2-2)x((4+3)/2)", 14.0),
        ("10/(2+3-1)x10", 25.0),
        ("(10+2)x2/10-10+(2-90)", -95.6),
        ("(1+2+(3-10)x2)+10-(19+20)/3+((10-2)-3/3x4)", -10.0),
    ];

    evaluate(PROBLEMS);
}
